package main

import (
	"strings"
	"text/template"
)

func typefor(sfdctype string) string {
	if len(sfdctype) == 0 {
		return "interface{}"
	}
	switch strings.ToLower(sfdctype) {
	case "address":
		return "*Address"
	case "boolean":
		return "bool"
	case
		"calculated",
		"combobox",
		"date",
		"datetime",
		"email",
		"encryptedstring",
		"id",
		"masterrecord",
		"multipicklist",
		"phone",
		"picklist",
		"reference",
		"string",
		"textarea",
		"time",
		"url":
		return "string"
	case
		"currency",
		"double",
		"percent":
		return "float64"
	case "int":
		return "int"
	case "junctionidlist":
		return "[]string"
	case "location":
		return "*Geolocation"
	}

	return "interface{}"
}

func cleanname(name string) string {
	name = strings.Replace(name, "__c", "", -1)
	if strings.Contains(name, "_") {
		newName := ""
		splitName := strings.Split(name, "_")
		for _, item := range splitName {
			if len(item) == 0 {
				continue
			}
			if len(item) == 1 {
				newName += strings.ToUpper(item)
				continue
			}
			if len(item) == 2 {
				if strings.ToUpper(item) == "ID" {
					newName += strings.ToUpper(item)
					continue
				}
			}
			newName += strings.ToUpper(string(item[0])) + string(item[1:])
		}
		name = newName
	}

	if strings.HasSuffix(name, "Id") {
		name = strings.TrimRight(name, "Id") + "ID"
	}
	if strings.HasSuffix(name, "Url") {
		name = strings.TrimRight(name, "Url") + "URL"
	}
	if strings.HasSuffix(name, "Api") {
		name = strings.TrimRight(name, "Api") + "API"
	}
	if strings.HasPrefix(name, "Api") {
		name = "API" + strings.TrimLeft(name, "Api")
	}

	return strings.Title(name)
}

func jsontag(tagName string) string {
	return "`json:\"" + tagName + "\"`"
}

func cleannamelower(name string) string {
	return strings.ToLower(cleanname(name))
}

func valueforkey(key string, m map[string]string) string {
	return m[key]
}

var generatedTmpl = template.Must(template.New("generated").Funcs(template.FuncMap{
	"jsontag":        jsontag,
	"cleanname":      cleanname,
	"cleannamelower": cleannamelower,
	"typefor":        typefor,
	"tolower":        strings.ToLower,
}).Parse(`
// generated by sfdc; DO NOT EDIT

package {{.PackageName}}

import (
	"encoding/json"
	"fmt"
	"net/url"
	"strings"
	"unicode/utf8"

	"golang.org/x/oauth2"
)

// {{cleanname .SObject.Name}} is the {{.SObject.Label}} SObject
type {{cleanname .SObject.Name}} struct {
  {{range .Fields}}{{cleanname .FieldName}} {{typefor .SObjectField.Type}} {{jsontag .SObjectField.Name}} // {{.SObjectField.Type}}
  {{end}}
}

type {{cleannamelower .SObject.Name}} struct {
	token       *oauth2.Token
	instanceURL string
	describeURL string
	sobjectURL  string
	queryURL    string
	queryAllURL string
}

// {{cleanname .SObject.Name}}QueryResponse is the result of a SOQL Query for the
// {{cleanname .SObject.Name}} object.
type {{cleanname .SObject.Name}}QueryResponse struct {
	Done           bool                          {{jsontag "done"}}
  NextRecordsURL string                        {{jsontag "nextRecordsUrl"}}
	Records        []{{cleanname .SObject.Name}} {{jsontag "records"}}
	TotalSize      int                           {{jsontag "totalSize"}}
}

func (o *{{cleannamelower .SObject.Name}}) AllFields() string {
	s := []string{}
	{{range .Fields}}s = append(s, "{{.SObjectField.Name}}")
	{{end}}
  return strings.Join(s, ", ")
}

func (o *{{cleannamelower .SObject.Name}}) Get(id string) (*{{cleanname .SObject.Name}}, error) {
	uri := fmt.Sprintf("%v/%v/%v", o.instanceURL, o.sobjectURL, id)
	b, err := doGet(uri, o.token.AccessToken)
	if err != nil {
		return nil, err
	}
	var r {{cleanname .SObject.Name}}
	err = json.Unmarshal(b, &r)
	if err != nil {
		return nil, err
	}
	return &r, nil
}

func (o *{{cleannamelower .SObject.Name}}) Query(fields string, constraints string) ([]{{cleanname .SObject.Name}}, error) {
	query := fmt.Sprintf("SELECT %v FROM {{cleanname .SObject.Name}}", fields)
	if utf8.RuneCountInString(constraints) > 0 {
		query = fmt.Sprintf("%v WHERE %v", query, constraints)
	}
	uri, _ := url.Parse(fmt.Sprintf("%v/%v", o.instanceURL, o.queryURL))
	q := uri.Query()
	q.Set("q", query)
	uri.RawQuery = q.Encode()

	b, err := doGet(uri.String(), o.token.AccessToken)
	if err != nil {
		return nil, err
	}
	var r {{cleanname .SObject.Name}}QueryResponse
	err = json.Unmarshal(b, &r)
	if err != nil {
		return nil, err
	}
	return r.Records, nil
}
`))

var commonTmpl = template.Must(template.New("common").Funcs(template.FuncMap{
	"jsontag":     jsontag,
	"cleanname":   cleanname,
	"typefor":     typefor,
	"tolower":     strings.ToLower,
	"valueforkey": valueforkey,
}).Parse(`
// generated by sfdc; DO NOT EDIT

package {{.PackageName}}

import (
	"fmt"
	"io/ioutil"
	"net/http"

	"golang.org/x/oauth2"
)

// API is a SalesForce REST API client.
type API struct {
	token        *oauth2.Token
	clientID     string
	clientSecret string
	username     string
	password     string
	instanceURL  string
	resourceURL  string
	queryURL     string
	queryAllURL  string
	{{range .Objects}}{{.ObjectName}} *{{tolower .ObjectName}}
	{{end}}
}

// New creates a SalesForce API that you can use to access the SalesForce REST
// API.
func New(clientID string, clientSecret string, username string, password string) (*API, error) {
	api := &API{
		clientID:     clientID,
		clientSecret: clientSecret,
		username:     username,
		password:     password,
		resourceURL:  "{{.ResourcesURI}}",
		queryURL:     "{{.ResourcesURI}}/query",
		queryAllURL:  "{{.ResourcesURI}}/queryAll",
	}
	err := api.Authorize()
	if err != nil {
		return nil, err
	}
	return api, nil
}

// Authorize fetches a new OAuth 2.0 access token from SalesForce and makes it
// available for use by the API.
func (api *API) Authorize() error {
	config := &oauth2.Config{
		ClientID:     api.clientID,
		ClientSecret: api.clientSecret,
		Scopes:       nil,
		Endpoint: oauth2.Endpoint{
			AuthURL:  "https://login.salesforce.com/services/oauth2/authorize",
			TokenURL: "https://login.salesforce.com/services/oauth2/token",
		},
	}

	token, err := config.PasswordCredentialsToken(oauth2.NoContext, api.username, api.password)
	if err != nil {
		return err
	}
	instanceURL := token.Extra("instance_url").(string)
	api.instanceURL = instanceURL
	{{range .Objects}}api.{{.ObjectName}} = &{{tolower .ObjectName}}{
		token: token,
		instanceURL: instanceURL,
		describeURL: "{{valueforkey "describe" .SObject.URLs}}",
		sobjectURL:  "{{valueforkey "sobject" .SObject.URLs}}",
		queryURL:    "{{.ResourcesURI}}/query",
		queryAllURL: "{{.ResourcesURI}}/queryAll",
	}
	{{end}}
	return nil
}

func doGet(uri string, accessToken string) ([]byte, error) {
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept", "application/json")
	req.Header.Set("Authorization", fmt.Sprintf("%v %v", "Bearer", accessToken))
	res, err := http.DefaultClient.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	b, err := ioutil.ReadAll(res.Body)
	if err != nil {
		return nil, err
	}
	return b, nil
}

// Address is a compound data type that contains address field data.
type Address struct {
  Accuracy string
  City string
  Country string
  CountryCode string
  Latitude string
  Longitude string
  PostalCode string
  State string
  StateCode string
  Street string
}

// Geolocation is a compound data type that contains latitude and logitude
// values for geolocation fields.
type Geolocation struct {
  Latitude string
  Logitude string
}
`))
