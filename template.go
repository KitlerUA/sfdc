package main

import (
	"strings"
	"text/template"
)

func typefor(sfdctype string) string {
	if len(sfdctype) == 0 {
		return "interface{}"
	}
	switch strings.ToLower(sfdctype) {
	case "address":
		return "*Address"
	case "boolean":
		return "bool"
	case
		"calculated",
		"combobox",
		"date",
		"datetime",
		"email",
		"encryptedstring",
		"id",
		"masterrecord",
		"multipicklist",
		"phone",
		"picklist",
		"reference",
		"string",
		"textarea",
		"time",
		"url":
		return "string"
	case
		"currency",
		"double",
		"percent":
		return "float64"
	case "int":
		return "int"
	case "junctionidlist":
		return "[]string"
	case "location":
		return "*Geolocation"
	}

	return "interface{}"
}

func cleanname(name string) string {
	name = strings.Replace(name, "__c", "", -1)
	if strings.Contains(name, "_") {
		newName := ""
		splitName := strings.Split(name, "_")
		for _, item := range splitName {
			if len(item) == 0 {
				continue
			}
			if len(item) == 1 {
				newName += strings.ToUpper(item)
				continue
			}
			if len(item) == 2 {
				if strings.ToUpper(item) == "ID" {
					newName += strings.ToUpper(item)
					continue
				}
			}
			newName += strings.ToUpper(string(item[0])) + string(item[1:])
		}
		name = newName
	}

	if strings.HasSuffix(name, "Id") {
		name = strings.TrimRight(name, "Id") + "ID"
	}
	if strings.HasSuffix(name, "Url") {
		name = strings.TrimRight(name, "Url") + "URL"
	}
	if strings.HasSuffix(name, "Api") {
		name = strings.TrimRight(name, "Api") + "API"
	}
	if strings.HasPrefix(name, "Api") {
		name = "API" + strings.TrimLeft(name, "Api")
	}

	return strings.Title(name)
}

func jsontag(tagName string) string {
	return "`json:\"" + tagName + "\"`"
}

func cleannamelower(name string) string {
	return strings.ToLower(cleanname(name))
}

func valueforkey(key string, m map[string]string) string {
	return m[key]
}

func backtick() string {
	return "`"
}

var generatedTmpl = template.Must(template.New("generated").Funcs(template.FuncMap{
	"jsontag":        jsontag,
	"cleanname":      cleanname,
	"cleannamelower": cleannamelower,
	"typefor":        typefor,
	"tolower":        strings.ToLower,
	"backtick":       backtick,
}).Parse(`
// generated by sfdc; DO NOT EDIT

package {{.PackageName}}

import (
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"strings"
	"unicode/utf8"
)

// {{cleanname .SObject.Name}} is the {{.SObject.Label}} SObject
type {{cleanname .SObject.Name}} struct {
  {{range .Fields}}{{cleanname .FieldName}} {{typefor .SObjectField.Type}} {{jsontag .SObjectField.Name}} // {{.SObjectField.Type}}
  {{end}}
}

type {{cleannamelower .SObject.Name}} struct {
	config      *Config
	InstanceURL string
	DescribeURL string
	SobjectURL  string
	QueryURL    string
	QueryAllURL string
}

// {{cleanname .SObject.Name}}QueryResponse is the result of a SOQL Query for the
// {{cleanname .SObject.Name}} object.
type {{cleanname .SObject.Name}}QueryResponse struct {
	Done           bool                          {{jsontag "done"}}
  NextRecordsURL string                        {{jsontag "nextRecordsUrl"}}
	Records        []{{cleanname .SObject.Name}} {{jsontag "records"}}
	TotalSize      int                           {{jsontag "totalSize"}}
}

func (o *{{cleannamelower .SObject.Name}}) AllFields() string {
	s := []string{}
	{{range .Fields}}s = append(s, "{{.SObjectField.Name}}")
	{{end}}
  return strings.Join(s, ", ")
}

func (o *{{cleannamelower .SObject.Name}}) BuildRequest(uri string) (*http.Request, error) {
	return buildRequest(uri, o.config.token)
}

func (o *{{cleannamelower .SObject.Name}}) Get(id string) (*{{cleanname .SObject.Name}}, error) {
	uri := fmt.Sprintf("%v/%v/%v", o.InstanceURL, o.SobjectURL, id)
	req, err := o.BuildRequest(uri)
	if err != nil {
		return nil, err
	}
	res, err := http.DefaultClient.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()

	var r {{cleanname .SObject.Name}}
	if err := json.NewDecoder(res.Body).Decode(&r); err != nil {
		return nil, err
	}
	return &r, nil
}

func (o *{{cleannamelower .SObject.Name}}) Query(fields string, constraints string) ([]{{cleanname .SObject.Name}}, error) {
	query := fmt.Sprintf("SELECT %v FROM {{cleanname .SObject.Name}}", fields)
	if utf8.RuneCountInString(constraints) > 0 {
		query = fmt.Sprintf("%v WHERE %v", query, constraints)
	}
	uri, _ := url.Parse(fmt.Sprintf("%v%v", o.InstanceURL, o.QueryURL))
	q := uri.Query()
	q.Set("q", query)
	uri.RawQuery = q.Encode()
	reqURI := uri.String()

	var r {{cleanname .SObject.Name}}QueryResponse
	results := r.Records
	for !r.Done {
		if r.NextRecordsURL != "" {
			reqURI = fmt.Sprintf("%v%v", o.InstanceURL, r.NextRecordsURL)
		}
		req, err := o.BuildRequest(reqURI)
		if err != nil {
			return nil, err
		}

		res, err := http.DefaultClient.Do(req)
		if err != nil {
			return nil, err
		}
		defer res.Body.Close()

		if err := json.NewDecoder(res.Body).Decode(&r); err != nil {
			return nil, err
		}
		results = append(results, r.Records...)
	}

	return results, nil
}
`))

var commonTmpl = template.Must(template.New("common").Funcs(template.FuncMap{
	"jsontag":     jsontag,
	"cleanname":   cleanname,
	"typefor":     typefor,
	"tolower":     strings.ToLower,
	"valueforkey": valueforkey,
	"backtick":    backtick,
}).Parse(`
// generated by sfdc; DO NOT EDIT

package {{.PackageName}}

import (
	"net/http"

	"golang.org/x/oauth2"
)

// Config is SFDC API configuration
type Config struct {
	token         *oauth2.Token
	Version       string {{backtick}}default:"v37.0"{{backtick}}
	ClientID      string {{backtick}}required:"true"{{backtick}}
	ClientSecret  string {{backtick}}required:"true"{{backtick}}
	Username      string {{backtick}}required:"true"{{backtick}}
	Password      string {{backtick}}required:"true"{{backtick}}
	SecurityToken string {{backtick}}required:"true"{{backtick}}
	Environment   string {{backtick}}default:"Production"{{backtick}}
}

// API is a SalesForce REST API client.
type API struct {
	config       *Config
	InstanceURL  string
	ResourceURL  string
	QueryURL     string
	QueryAllURL  string
	{{range .Objects}}{{.ObjectName}} *{{tolower .ObjectName}}
	{{end}}
}

// New creates a SalesForce API that you can use to access the SalesForce REST
// API.
func New(c *Config) *API {
	api := &API{
		config: c,
		ResourceURL:  "{{.ResourcesURI}}",
		QueryURL:     "{{.ResourcesURI}}/query",
		QueryAllURL:  "{{.ResourcesURI}}/queryAll",
		{{range .Objects}}{{.ObjectName}}: &{{tolower .ObjectName}} {
			config: c,
		},
		{{end}}
	}

	return api
}

// Authorize fetches a new OAuth 2.0 access token from SalesForce and makes it
// available for use by the API.
func (api *API) Authorize() error {
	config := &oauth2.Config{
		ClientID:     api.config.ClientID,
		ClientSecret: api.config.ClientSecret,
		Scopes:       nil,
		Endpoint: oauth2.Endpoint{
			AuthURL:  "https://login.salesforce.com/services/oauth2/authorize",
			TokenURL: "https://login.salesforce.com/services/oauth2/token",
		},
	}

	token, err := config.PasswordCredentialsToken(oauth2.NoContext, api.config.Username, api.config.Password)
	if err != nil {
		return err
	}
	instanceURL := token.Extra("instance_url").(string)
	api.InstanceURL = instanceURL
	{{range .Objects}}api.{{.ObjectName}} = &{{tolower .ObjectName}}{
		config:      api.config,
		InstanceURL: instanceURL,
		DescribeURL: "{{valueforkey "describe" .SObject.URLs}}",
		SobjectURL:  "{{valueforkey "sobject" .SObject.URLs}}",
		QueryURL:    "{{.ResourcesURI}}/query",
		QueryAllURL: "{{.ResourcesURI}}/queryAll",
	}
	{{end}}
	return nil
}

// BuildRequest creates an http.Request with defaults set for SFDC
func buildRequest(uri string, accessToken *oauth2.Token) (*http.Request, error) {
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept", "application/json")
	if accessToken != nil {
		accessToken.SetAuthHeader(req)
	}

	return req, nil
}

// Address is a compound data type that contains address field data.
type Address struct {
  Accuracy string
  City string
  Country string
  CountryCode string
  Latitude string
  Longitude string
  PostalCode string
  State string
  StateCode string
  Street string
}

// Geolocation is a compound data type that contains latitude and logitude
// values for geolocation fields.
type Geolocation struct {
  Latitude string
  Logitude string
}
`))
